
0. Spring Boot Actuator란.
  - Spring Boot Actuator는 애플리케이션의 상태 모니터링, 메트릭 수집, 트래픽 추적 등 운영(Production) 환경에 필요한 기능을 제공하는 관리 도구입니다.
  - HTTP 엔드포인트나 JMX를 통해 JVM 메모리, CPU 사용량, 로그백 이벤트, DB 연결 상태 등의 정보를 JSON 형식으로 손쉽게 확인하여 애플리케이션의 동작을 제어하고 분석할 수 있게 합니다.
  - 주로 Prometheus, Grafana, Spring Boot Admin 등과 연동하여 시각화된 모니터링 환경을 구축하는 데 필수적으로 사용됩니다.
  - 핵심 특징 및 기능:
    - 간편한 모니터링: 별도 코드 구현 없이 의존성 추가만으로 다양한 운영 지표 제공.
    - 엔드포인트(Endpoint) 제공: http://localhost:8080/actuator를 통해 헬스 체크(health), 메트릭(metrics), 빈 목록(beans) 등 데이터 접근.
    - 상태 정보: jvm.memory.used(메모리 사용량), system.cpu.count(CPU 개수), http.server.requests(요청 처리) 등의 지표 수집.
    - 운영 최적화: 시스템의 건강 상태를 진단하여 안정적인 서비스 운영 지원.
    - 주요 활용 엔드포인트:
      - /health: 애플리케이션의 상태(Up/Down)를 확인.
      - /metrics: 애플리케이션의 메트릭 데이터(메모리, CPU 등)를 보여줌.
      - /loggers: 로그 레벨을 조회하거나 운영 중에 변경 가능.
  - Registry
    - Spring Boot에서 Registry(레지스트리)는 주로 마이크로서비스 아키텍처(MSA) 환경에서
    - 서비스의 위치 정보(IP, 포트 등)를 저장하고 관리하는 Service Registry(서비스 레지스트리)를 의미.
    - 마이크로 서비스가 시작될 때 자신의 정보를 등록하고, 다른 서비스의 위치를 찾아 호출할 수 있게 해주는 중추적인 역할.

1. 프로젝트 생성.
  새 프로젝트 만들기.
    - https://start.spring.io/
  메이븐의 starter 란.
    - bean 까지 만들어줌.
    - 기본 동작이 다 동작을 해버림.
    - 기본 설정 OK.
    - http://localhost:8080/actuator
  헤이티오스.
    - 한번 찾아보기.
    - 링크주고, 타고타서, 정보를 알수있다.
  intellij: cannot find symbol
    - https://intellij-support.jetbrains.com/hc/en-us/community/posts/23064675521682-Lombok-not-workin-with-Intellij
    - 파일 > 설정 > 빌드, 실행, 배포 > 컴파일러 > 어노테이션 프로세서
    - 어노테이션 처리 활성화 - 체크
    - 프로세서경로의 lombok.jar 확인 또는 경로 재설정.

2. 공식 가이드 페이지, 의존성라이브러리.
  강의자료
    - https://semtul79.tistory.com/category/spring%20boot/actuator%20in%20spring%20boot?page=2
  스프링부트 공식 문서
    - https://docs.spring.io/spring-boot/reference/index.html
    - https://docs.spring.io/spring-boot/reference/actuator/enabling.html
  메이븐
    - 스프링부트 엑츄에이터는 micrometer-core 를 쓰고있음.
  스프링부트 오토 컨피그레이션 기능
    - @ConditionalOnMissionBean, @ConditionalOnClass
    - 기능으로 특정 클래스가 있으면 Bean 으로 생성해줌.
    - 리소스 낭비를 줄이기 위해.

3. 엔드포인트 설정.
  엔드포인트란
    - 엔드포인트는 정보를 얻을수 있는 링크. 정확히는 url 을 actuator 에서는 endpoint 라고 부릅니다.
    - 즉, http://localhost:8080/actuator/health <-- 이런 url 이 각각 endpoint 가 됩니다.
  보이는 엔드포인트가 적은 이유?
    - actuator 에서는 java version, OS 버전 과 같은 다양한 정보를 제공해주는데
    - 이런 정보는 누구에게나 open 되면 보안상 좋지 않기에,
    - spring boot 에서는 default 설정으로는 위와 같이 2~3개로 제한시켜져 있기 때문입니다.
  기본 제공되는 endpoints
    - https://docs.spring.io/spring-boot/reference/actuator/endpoints.html#actuator.endpoints
    - beans, caches, conditions, health, info, metrics, logger, quartz
  활성화설정, 노출설정.
    - endpoint 는 enable/disable (활성화 여부)과 expose ( 노출 여부 ) 라는 2가지 설정을 할 수 있으며 2가지 모두 켜진 상태여야 외부로 노출이 됩니다.
    - default 설정으로 활성화된 endpoint 는 shutdown 이라는 endpoint 를 제외하고 모두 활성화 되어 있습니다.
    - endpoint 는 각각의 활성화, endpoints 는 노출 관련.
    - 특정 엔드포인트는 Requires 로 자동으로 활성화되려면 요구조건이 있다.
    - properties 파일에서는 * 는 허용하지만, yml은 "*" 으로 해야 함.
  보안 문제.
    - spring security 를 통해 /actuator url 에 대해 http basic auth 을 적용해서 id, pw 가 맞아야만 pass 되도록 하면 됨.
    - spring security http basic auth 라고 구글링 하면 많은 정보가 나옴
  캐시
    - 각 활설화 설정(endpoint)에서 캐시 값을 설정 할 수 있음.
  CORS
    - 간혹 web 화면에서 endpoint 를 호출해야할 수도 있습니다.
    - 노출 설정(endpoints)에서 cors를 허용할 수 있음.

4. 커스텀 엔드포인트.
  실무에서 사내 정책에 따라 사내 전용 endpoint 가 필요한 경우가 있습니다.
  가이드
    - https://docs.spring.io/spring-boot/reference/actuator/endpoints.html#actuator.endpoints.implementing-custom
  실습
    - MyLibraryInfoEndpoint.java
    - 현재 app에서 사용중인 라이브러리들의 이름과 버전정보를 응답으로 리턴하는 custom endpoint 를 만들 필요가 있다고 가정.
    - class
      - @Endpoint(id = "myLibraryInfo")
      - 엔드포인트는 value가 없어서 id를 지정해야함.
      - @WebEndpoint 로 web에서만 동작하게 만들 수 있음. (jmx는 안됨)
    - method
      - @ReadOperation: GET
        - @Selector 를 통해 Pathvariable 가능.
      - @WriteOperation: POST
        - dto는 안됨.
      - @DeleteOperation: DELETE
    - config
      - MyLibraryInfoEndpointConfig.java
      - 대신 @Component 써도됨.
    - @Nullable
      - org.springframework.lang.Nullable 을 써야 정상동작.
    - 권장하지 않음
      - @RestControllerEndpoint, @ServletEndpoint
  결국 rest controller 를 만들면 되는거니 굳이 actuator 가 아닌 직접 rest controller 만들면 되지 않나?
    - 그러나 직접 rest controller 로 만들어버리면,
    - prometheus 와 같은  actuator 와 호환이 되는 여러 라이브러리와 연동이 될수 없습니다.
    - 즉 actuator 가 일종의 인터페이스 역할이므로 다른 라이브러리와의 연동을 위해 actuator 를 이용하는게 좋습니다.

5. 헬스 엔드포인트.
  management.endpoint.health
    - show-components:
      - ALWAYS, NEVER, WHEN_AUTHORIZED
    - show-details:
      - 상세 항목이 나옴.
      - ALWAYS, NEVER, WHEN_AUTHORIZED
  기본 헬스 정보들.
    - https://docs.spring.io/spring-boot/reference/actuator/endpoints.html#actuator.endpoints.health.auto-configured-health-indicators
    - 안쓰고 있는 건 안나옴.
    - db 헬스 정보는 DataSourceHealthIndicator.java 를 사용하고 있음.
  커스텀 헬스엔드포인트 실습
    - MyCustomHealthIndicator.java
    - 왜하냐?
      - 상용엔드포인트를 구현해야하는데 지원하는게 없다면, 내가 직접 만들어서 제공한다!
    - HealthIndicator.class 의 health() 함수를 오버라이드 해야 함.
    - HealthIndicator 를 제외한 "MyCustom" 이 이름으로 됨. (공식 가이드)
    - 전체 health status 는 components 중 하나가 down이면 down으로 됨.
      - down 이면 http reponse status code: 503
    - DataSourceHealthIndicator 는 누가 Bean 생성해주냐?
      - 생성자에 블랙포인트 걸어두고 디버그!
      - DataSourceHealthContributorAutoConfiguration 이 Bean으로 만들어줌.
      - j2, jpa 디펜던시 추가.

6. 인포 엔드포인트.
  다섯가지 기본 제공.
    - https://docs.spring.io/spring-boot/reference/actuator/endpoints.html#actuator.endpoints.info.auto-configured-info-contributors
  변수 입력하기
    - @xxxx.xxxx@ 형태, gradle은 ${xxx.xxx}
    - 공식 가이드. springboot 에서 지원하는 거임. actuator 전용이 아님.
    - actuator.env 에 actuator.env.info 로도 표현됨.
    - management.endpoint.env.show-values 로 value 볼 수 있음.
  선결 조건 git
    - https://docs.spring.io/spring-boot/how-to/build.html#howto.build.generate-git-info
    - pom.xml plug-in 추가.
    - Maven.actuator-demo.plugin.git-commit-id.git-commit-id:revision 더블클릭!
    - target.classes 아래 git.properties 파일이 생성되어야 함.
    - info.git.mode: FULL 로 정보를 다 보이게 할 수 있다.
  선결 조건 build
    - https://docs.spring.io/spring-boot/docs/3.0.4/reference/html/howto.html#howto.build.generate-info
    - pom.xml plug-in 추가.
    - Maven.actuator-demo.plugin.spring-boot.spring-boot:build-info 더블클릭!
    - target.classes.META-INF 아래 build-info.properties 파일이 생성되어야 함.
    - git.build 도 있음. 헷갈리지마시길.
  커스텀 인포 엔드포인트 실습.
    - MyCustomInfoContributor.java
    - Contributor 를 제외한 "MyCustomInfo" 이 이름으로 됨. (공식 가이드)

7. 메트릭스 엔드포인트
    가장 중요한~~!
      - http://localhost:8080/actuator/metrics/process.cpu.usage
      - https://docs.spring.io/spring-boot/reference/actuator/metrics.html#actuator.metrics.supported
      - 일반적으로 통합 모니터링을 구출. 몽땅 다 모아서, 한번에 보게,,,
      - 마이크로미터의 공식 가이드를 참고해야 함.
        - https://micrometer.io/docs/concepts
    외부 모니터링 시스템과의 연동
      - datadog, elastic, prometheus, stackdriver, dynatrace, influx
        - datadog 에는  json(예) 형태로 metric 정보를 전달해야 하고,
        - elastic 에는 xml(예) 형태로 전달해야 하고,
        - prometheus 에는 json, xml 도 아닌 proemtheus 자체 포맷으로 전달해야 하고,
        - 또 다른 시스템에는 tcp로 데이터를 push해야 할수도 있고,
        - 또 다른 어떤 시스템에는 polling 해야 할수도 있고...
      - spring 에서는 actuator 를 통해 이런 다양한 프로토콜과 쉽게 연동이 가능하도록 지원해주고 있습니다.
        - https://docs.spring.io/spring-boot/reference/actuator/metrics.html#actuator.metrics.export.elastic
    커스텀 메트릭스 엔드포인트 실습.
      - 메트릭스는 커스텀을 만드는게 좋다.
      - 요청건수, 처리건수, 주문건수 등등
      - 이러는 애를 통합 모니터링으로 써야함
      - https://docs.spring.io/spring-boot/reference/actuator/metrics.html#actuator.metrics.registering-custom
      - MyStockManager.java
      - MyStockMeterBinderConfig.java

8. 매트릭스 엔트포인트 - 카운터
  공식가이드
    - https://micrometer.io/docs/concepts#_counters0
  Counter란.
    - Counter 는 이름 그대로 횟수를 세어 metric 으로 제공합니다.
    - 횟수이므로 1, 2, 100, 3000 처럼 자연수만 가능하지 1.3 처럼 소수나 -10 처럼 음수는 불가능합니다.
    - 일반적으로 cache hit 에 대한 누적 counter, http request 누적 횟수 counter 와 같이
    - 지금까지 특정 이벤트가 몇번 발생했는지를 누적값으로 제공할때 Counter 를 사용하면 됩니다.
  카운터 실습
    - 보통은 filter나 interceptor를 통해 특정 URL에 사용하긴 함.
    - 주로 FunctionCounter.builder 방식을 많이 사용함.
    - 만드는 방법 설명
      1. Manager 로 실행하는 함수를 만든다.
      2. @Configuration @PostConstruct-Counter 를 이용해서 카운터를 생성한다.
      3. @Configuration @PostConstruct-FunctionCounter 를 이용해서 카운터를 생성한다.
      4. 또는 @Configuration @Bean-MeterBinder 를 이용해서 카운터를 생성한다.
      5. 또는 CountedAspect @Aspect @Counted 를 이용해서 카운터를 생성한다.
      6. http://localhost:8080/actuator/metrics/my.function.counter 에서 확인 한다.
    - CounterController.java
    - MyHttpRequestManager.java
  펑션 카운터 실습
    - CounterController.java
    - MyHttpRequestManagerWithoutMicrometer.java
    - MyFunctionCounterConfig.java
    - CounterConfigWithMeterBinder.java
  @Aspect @Counted 카운터 실습.
    - @Counted 를 구현하려면 CountedAspect 빈을 구현해야함.
    - CounterController.java
    - CountConfig.java

9. 매트릭스 TAG의 옵션.
  - http://localhost:8080/actuator/metrics/jvm.memory.max?tag=area:nonheap&tag=id:Compressed%20Class%20Space
  - tag를 활용한 querystring으로 heap 과 nonheap 을 구분해서 볼 수 있음.
  메트릭스 카운터 태그 실습
    - MyQueueManagerWithTags.java
    - TagController.java
    - http://localhost:8080/actuator/metrics/my.queue.counter?tag=type:push
  메트릭스 카운터 태그 실습 with 어노테이션
    - TagController.java
    - http://localhost:8080/actuator/metrics/my.queue.counted?tag=method:pop
    - push 와 pop 의 카운터는 서로 다른 카운터이다.
    - Counter.builder 의 name, tags, baseUnit 등으로 별개의 카운터가 만들어짐.

10. 매트릭스 엔드포인트 - 게이지.
  Gauge란.
    - Gauge 는 자동차 속도 계기판과 같이 커졌다 작아졌다 할 수 있는 값에 사용됩니다.
    - 보통 cpu usage, mem usage, 사용중인 thread count, 사용중인 connection pool count 등에 사용됩니다.
    - thread count 라고 해서 Counter 를 쓰는게 맞지 않냐? 라고 생각할 수 있으나
    - 사용중인 thread count는 커졌다 작아졌다 할 수 있으므로 Gauge 가 맞습니다.
  게이지 실습.
    - 만드는 방법 설명
      1. Manager 로 실행하는 함수를 만든다.
      2. @Configuration @PostConstruct 를 이용해서 게이지를 생성한다.
      3. 또는 @Configuration @Bean-MeterBinder 를 이용해서 게이지를 생성한다.
      4. http://localhost:8080/actuator/metrics/my.queue.size 에서 확인 한다.
    - QueueManager.java
    - GaugeConfig.java
    - GaugeConfigWithMeterBinder.java

11. 매트릭스 엔드포인트 - 타이머
  Timer란.
    - 이름 그대로 시간을 측정하는 metric 입니다.
  타이머 실습.
    - 만드는 방법 설명
      1. @Configuration @Bean-Timer 를 이용해서 타이머를 생성한다.
      2. Manager + FunctionTimer.builder 를 이용하여 타이머를 생성.
      3. timer.record 를 이용해서 타이머를 실행.
      4. Timer.Sample 를 이용해서 개별 타이머를 실행.
      5. @Timed 를 이용해서 타이머를 실행.
      5. http://localhost:8080/actuator/metrics/my.timer 에서 확인 한다.
    - TimerConfig.java
    - TimerController.java
  개별 타이머 실습.
    - Timer.Sample 을 사용해서 개별적인 비즈니스 로직으로 만들 수 있음.
  @Aspect @Timed 타이머 실습.
    - @Timed 를 구현하려면 TimedAspect 빈을 구현해야함.
    - TimedConfiguration.java
    - TimerController.java
  FunctionTimer 타이머 실습
    - FunctionTimerConfig.java
    - MyTimerManager.java
  MeterBinder 타이머 실습
    - TimerConfigMeterBinder.java
    - MyTimerManager.java

12. 메트릭스 정리.
  https://semtul79.tistory.com/22
  - 어노테이션 지원
    - @Counted, @Timed, 게이지는 없음!
  - 스프링에서 관리하는 메트릭스.
    - Counter.increment()
    - Timer.timer()
  - 직접 관리하는 메트릭스.
    - FuncitonCounter.builder
    - FunctionTimer.builder
    - Gauge.builder (게이지는 그냥 게이지임)
  - MeterBinder 를 이용한 메트릭스 등록.
    - FuncitonCounter, FunctionTimer, Gauge
  - 이름 기준.
    - my.metrics.type

13. 스프링 부트 어드민.
  어드민을 사용해야 하는 이유?
    - actuator 의 값을 보기 위해 웹브라우저에 http://127.0.0.1:8080/actuator/ 로 시작하는 url 을 넣고 일일이 확인을 했습니다.
    - 여러 application이 있을때, ip가 서로 다를 것이므로 일일이 ip를 변경해가면서 값을 확인해야 합니다
    - 단순히 조회만 할것이면 웹브라우저로 가능하나,
    - 값을 변경하는 작업은 HTTP GET이 아닌 HTTP PUT, POST 와 같은 걸 사용해야 하는데 웹브라우저 자체는 이를 지원하지 않습니다.
    - 게다가 json 형식으로 아주 많은 데이터가 나올 경우 눈으로 일일이 확인하기가 어렵습니다.
    - spring boot admin 에서는 UI 를 제공하기에 마우스 클릭만으로 쉽게 값 조회/수정이 가능하다.
    - 여러 application 의 actuator 정보를 server 로 모아서 통합관리할 수 있습니다.
    - spring boot admin 은 서버와 클라이언트로 구분되며,
    - actuator를 통해 정보를 제공하는 쪽이 client 이며,
    - actuator의 정보를 수집해서 ui로 보여주는게 server 입니다.
    - spring boot 기반 application에 library 형태로 추가해주면 동작을 합니다.
  어드민 실습.
    - admin 서버 프로젝트를 만들어야 함.
      - @SpringBootApplication 에 @EnableAdminServer 어노테이션 추가.
        - 서버를 동작하기 위해서는 AutoConfiguration 같이 자동으로 빈으로 만들어줘야 함.
          - @EnableAdminServer 동작하면.
          - @Import(AdminServerMarkerConfiguration) 의 Marker를 빈으로 만들게 됨.
          - @ConditionalOnBean(AdminServerMarkerConfiguration.Marker.class) 를 감지하여
          - AdminServerAutoConfiguration 가 동작하게 된다.
      - pom.xml 에 spring-boot-admin-starter-server 추가.
      - application.yml 에 기동 포트(9090) 추가.
    - admin 클라이언트 프로젝트 추가해야함.
      - 사용하는 프로젝트 application.yml 에
        - 접속서버: spring.boot.admin.client.url: http://127.0.0.1:9090
        - 통신주기: spring.boot.admin.client.period: 1000ms (필수는 아닌듯)
      - pom.xml 에 spring-boot-admin-starter-client 추가.
    - admin server 에 접속하면 끝.
      - 대시보드 - 어플리케이션 진입
      - 깃정보, 빌드정보, 인포정보, 프로세스, 스레스, 가비지, 메모리, 캐시
      - 메트릭스 지표
      - 설정된 환경변수, 빈, 속성, 스케줄 정보.
      - 로그레벨을 실시간으로 설정할 수 있음.
      - JVM - 스레드 덤프.
      - 엔드포인트 맵핑 정보들 잘 나옴.
  스프링 부트 어드민 설명.
    - spring boot admin 은 actuator 의 다양한 정보를 쉽게 알 수 있으나, 1시간전과 같이 예전 값을 저장하기가 어렵습니다.
    - 그래서 실무에서는 spring boot admin 보다는 prometheus, grafana 와 같은 통합 모니터링 도구를 이용하는게 더 일반적입니다.
    - 다만 힙덤프, 쓰레드덤프 와 같이 조회가 아닌 특정 작업을 수행할 경우에는 spring boot admin이 더 효과적이며,
    - prometheus, grafana 조합에 비해 단순히 라이브러리 추가만으로 쉽게 구축이 가능하므로, 용도에 맞게 사용하시기 바랍니다.

14. 마무리.
  - actuator + prometheus + grafana 까지 구성하여 전체 흐름을 모두 설명하고자 했으나,
  - actuator 사용법만 다루면 내부 동작 원리를 하나도 모를듯 하여, 가끔씩 내부 코드도 살펴보면서 동작 원리를 설명하였습니다.
  - 마지막으로 actuator 를 통해 app의 다양한 정보를 조회하고 수정할 수 있기에 사내 보안정책을 확인하고 적절한 설정을 해줘야 합니다.
    - /actuator 가 아닌 다른 path 을 사용.
    - 8080 이 아닌 다른 port 를 사용
    - actuator endpoint에 대한 인증,인가 적용
    - actuator endpoint 중 필요한 것만 노출하도록 설정